<!doctype html>
<meta charset=utf-8>
<title>DOMException behaves mostly like an interface, with a few custom bindings</title>
<link rel="help" href="https://heycam.github.io/webidl/#es-DOMException-constructor-object">
<link rel="help" href="https://github.com/heycam/webidl/pull/378">
<link rel="author" title="Domenic Denicola" href="mailto:d@domenic.me">
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>

<script>
"use strict";

test(() => {
  assert_throws(new TypeError(), () => DOMException());
}, "Cannot construct without new");

test(() => {
  assert_equals(Object.getPrototypeOf(DOMException.prototype), Error.prototype);
}, "inherits from Error: prototype-side");

test(() => {
  assert_equals(Object.getPrototypeOf(DOMException), Function.prototype);
}, "does not inherit from Error: class-side");

test(() => {
  const e = new DOMException("message", "name");
  assert_false(e.hasOwnProperty("message"), "property is not own");

  const propDesc = Object.getOwnPropertyDescriptor(DOMException.prototype, "message");
  assert_equals(typeof propDesc.get, "function", "property descriptor is a getter");
  assert_equals(propDesc.set, undefined, "property descriptor is not a getter");
  assert_true(propDesc.enumerable, "property descriptor enumerable");
  assert_true(propDesc.configurable, "property descriptor configurable");
}, "message property descriptor");

test(() => {
  const e = new DOMException("message", "name");
  assert_false(e.hasOwnProperty("name"), "property is not own");

  const propDesc = Object.getOwnPropertyDescriptor(DOMException.prototype, "name");
  assert_equals(typeof propDesc.get, "function", "property descriptor is a getter");
  assert_equals(propDesc.set, undefined, "property descriptor is not a getter");
  assert_true(propDesc.enumerable, "property descriptor enumerable");
  assert_true(propDesc.configurable, "property descriptor configurable");
}, "name property descriptor");

test(() => {
  const e = new DOMException("message", "name");
  assert_false(e.hasOwnProperty("code"), "property is not own");

  const propDesc = Object.getOwnPropertyDescriptor(DOMException.prototype, "code");
  assert_equals(typeof propDesc.get, "function", "property descriptor is a getter");
  assert_equals(propDesc.set, undefined, "property descriptor is not a getter");
  assert_true(propDesc.enumerable, "property descriptor enumerable");
  assert_true(propDesc.configurable, "property descriptor configurable");
}, "code property descriptor");

test(() => {
  const e = new DOMException("message", "InvalidCharacterError");
  assert_equals(e.code, 5, "Initially the code is set to 5");

  Object.defineProperty(e, "name", {
    value: "WrongDocumentError"
  });

  assert_equals(e.code, 5, "The code is still set to 5");
}, "code property is not affected by shadowing the name property");

test(() => {
  const e = new DOMException("message", "name");
  assert_equals(Object.prototype.toString.call(e), "[object DOMException]");
}, "Object.prototype.toString behavior is like other interfaces");

test(() => {
  const e = new DOMException("message", "name");
  assert_equals(typeof DOMException.prototype.toString, "function", "toString exists on the DOMException prototype");
  assert_equals(e.toString(), "name: message", "toString() returns the concatenation");
}, "toString() is defined like for other interfaces, and behaves correctly");

test(() => {
  let stackOnNormalErrors;
  try {
    throw new Error("normal error");
  } catch (e) {
    stackOnNormalErrors = e.stack;
  }

  let stackOnDOMException;
  try {
    throw new DOMException("message", "name");
  } catch (e) {
    stackOnDOMException = e.stack;
  }

  assert_equals(typeof stackOnDOMException, typeof stackOnNormalErrors, "The typeof values must match");
}, "If the implementation has a stack property on normal errors, it also does on DOMExceptions");
</script>
